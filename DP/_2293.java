import java.util.*;

public class Main {
	
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);    
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] arr = new int[n+1];
        int[] dp = new int[k+1];
        dp[0]=1;
        
        for(int i=1; i<=n; i++) {
        	arr[i] = sc.nextInt();
        	// n가지 종류의 동전을 사용하여 k원을 만드는 경우의 수
        	// 이때 동전의 구성이 같고 순서가 다른 것은 동일한 case       	
        	for(int j=1; j<=k; j++) {
	        	/* 1,2,5원으로 10원을 만드는 경우의 수를 살펴보자.
	        	 dp[1] = 1 (1)
	        	 dp[2] = 2 (11/2)
	        	 dp[3] = 2 (111/12)
	        	 dp[4] = 3 (1111/112/22)
	        	 dp[5] = 4 (11111/1112/122/5)
	        	 dp[6] = 5 (111111/11112/1122/15/222)
	        	 dp[7] = 6 (1111111/111112/11122/1222/115/25)
	        	 dp[8] = 7 (11111111/1111112/111122/11222/2222/1115/125)
	        	 dp[9] = 8 (111111111/11111112/1111122/111222/12222/11115/1125/225)
	        	 dp[10] = 10
	        	 인덱스값이 하나씩 늘어날 때마다 새로 case를 세는 방식은 불가능하다.
	        	 j원을 만들 때 (j원-각 동전의 가격)원의 경우만 모아준다면 자동으로 case가 확정된다.	예제를 살펴보자.
	        	 
	        	 1원으로만, 1/2원으로만, 1/2/5원으로 만드는 경우의 수를 <목표 값이 현재 동전값보다 작지 않을 때> 모두 더해주면 그게 답이다.
	        	 1원으로만 만드는 경우의 수는 k값과 상관없이 무조건 1이다. (1)	        	  	 
	        	 1/2원으로 만드는 경우의 수는, 2원 하나만 더하면 10원이 되는 경우를 찾으면 된다.
	        	 -> 즉 1/2원만 사용할 수 있을 때, 8원을 만드는 경우가 답일 것이다. (5)
	        	 1/2/5원으로 만드는 경우의 수는, 5원 하나만 더하면 10원이 되는 경우를 찾으면 된다.
	        	 -> 즉 1/2/5원을 사용할 수 있을 때, 5원을 만드는 경우가 답일 것이다. (4)
	        	 그렇게 10이 만들어진다. 점화식으로 나타내면 아래와 같다.
	        	 
	        	 */  		
        		if(j>=arr[i]) {
        			dp[j] += dp[j-arr[i]];
        		
        		}
        		// 최종 점화식
	        }
        }
        
        System.out.println(dp[k]);
    } 
}